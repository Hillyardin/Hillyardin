%#################################
% GutMap 2014-2024
%#################################

function contraction_callback(in, guiHandle)
% ------------------------------------------------------------------------
%   ROLE
%
% Manages the creation of, and storage of information pertaining to, labels
% on the heatmap contained in the window named heatmapAnnotationPanel. 
% These callbacks are intended for use as a part of the GUI generated by
% analyse2.m.
% 
% ------------------------------------------------------------------------
%   DESCRIPTION
%
% CONTRACTION_CALLBACK(ARGIN, HGUI) manages the creation and removal of 
% lines on the heatmap of the current file and their associated data, 
% contained in the GUI with handle HGUI. ARGIN can take one of several 
% values, shown below:
%
%   - 'Create label' enables the user to annotate the heatmap with a line
%     that can later be dragged and modified. The information regarding 
%	  the slope and positioning of the label is stored.
%
%   - 'Auto label' attempts to automatically detect and label contraction
%	  events in the heatmap, and stores the information obtained for each
%	  of these labels.
%
%   - 'Populate labels' takes the information stored for each label, and 
%	  fills the table contained in the GUI with relevant information such
%	  as duration, location, and velocity.
%
% ------------------------------------------------------------------------
imageHandle = findobj(guiHandle, 'Tag', 'heatmapImage');
heatmapAxes = get(imageHandle, 'Parent');
XLims = get(heatmapAxes, 'XLim');
YLims = get(heatmapAxes, 'YLim');

switch in
    
    case 'Create label'
	
		% Create new line
        newLabel = imline(heatmapAxes);
        setPositionConstraintFcn(newLabel, makeConstrainToRectFcn('imline', XLims, YLims));
        
		% Find first unused ID number
        labels = get(imageHandle, 'UserData');
        n = 1;
        if ~isempty(labels)
            ids = [labels.id];
            while ~isempty(find(ids == n,1))
                n = n + 1;
            end
        end
		
		% Store data relating to new  line
        newData = struct('id'      , n       , ...
                         'name'    , ['Label ' num2str(n)], ...
                         'selected', false        , ...
                         'line'    , newLabel     , ...
                         'method'  , 'Manual'     );
		
		% Store data and populate table
        set(imageHandle, 'UserData', [labels newData])
        contraction_callback('Populate labels', guiHandle)
        
    case 'Auto label'
        
        waitHandle = waitDialog;
        
        CData = get(imageHandle, 'CData');
        lData = get(imageHandle, 'UserData');
        M = size(CData, 1);
        N = size(CData, 2);
		
		% Determine a cutoff value that selects points which contain values within the lowest
		% 25% of the range of values in the heatmap. NOTE: This is hardcoded and does not factor
		% in dropped values (ie. zero values)
        percentile = 0.25;
        cutoff = max(CData(:)) * percentile + min(CData(:)) * (1-percentile);
        
		[regions, num] = bwlabel(CData < cutoff);
        
		
        XStep = (XLims(2) - XLims(1))/(N-1);
        YStep = (YLims(2) - YLims(1))/(M-1);
        for i = 1 : num
            region = (regions == i);
            total = sum(region(:));
			
			% Restrict to clusters with at least 100 pixels
            if total > 100
                vertProj = sum(region,1);
                datapts = zeros(N,2);
                count = 0;
				% Obtain the vertical mean and store the coordinates
                for j = 1 : N
                    if vertProj(j)
                        count = count + 1;
                        datapts(count,:) = [j, sum((1:M)' .* region(:,j))/vertProj(j)];
                    end
                end
                datapts = datapts(1:count,:);
				
				% Fit a polynomial to the collected points
                p = polyfit(datapts(:,1), datapts(:,2),1);
                xData = [find(vertProj,1) find(vertProj,1, 'last')];
                yData = round(p(1) .* xData + p(2));
                
                xData = XLims(1) + XStep .* (xData - 1);
                yData = YLims(1) + YStep .* (yData - 1);
                
				% Create a label which spans the horizontal domain
                newLabel = imline(heatmapAxes, xData, yData);
                setPositionConstraintFcn(newLabel, makeConstrainToRectFcn('imline', XLims, YLims));
                
				% Store the new label
                n = 1;
                if ~isempty(lData)
                    ids = [lData.id];
                    while ~isempty(find(ids == n,1))
                        n = n + 1;
                    end
                end

                newData = struct('id'      , n       , ...
                                 'name'    , ['Label ' num2str(n)], ...
                                 'selected', false        , ...
                                 'line'    , newLabel     , ...
                                 'method'  , 'Automatic'     );
                lData = [lData newData];
            end
        end
		
		% Populate the table
        set(imageHandle, 'UserData', lData)
        contraction_callback('Populate labels', guiHandle)
        
        close(waitHandle);
        
    case 'Populate labels'
	
		% Obtain all of the stored labels
        lData = get(imageHandle, 'UserData');
        L = length(lData);
        tableData = cell(L, 5);
		
		% For each row in the table, fill in the cells
        for i = 1 : L
            tableData{i,1} = lData(i).name;
            tableData{i,2} = lData(i).selected;
            
            position = getPosition(lData(i).line);
            
            xData = position(:,1);
            yData = position(:,2);
            
            velocity = (yData(2)-yData(1))/(xData(2) -xData(1));

            tableData{i,3} = sprintf('%.3f', velocity);
            tableData{i,4} = sprintf('%.2f', abs(xData(2) - xData(1)));
            tableData{i,5} = sprintf('%.1f', max(yData(:)) - min(yData(:)));
            tableData{i,6} = lData(i).method;
            
			% Color the lines red if selected, and blue otherwise.
            if lData(i).selected
                setColor(lData(i).line, 'r');
            else
                setColor(lData(i).line, 'b');
            end
            
        end
        
        set(findobj(guiHandle, 'Tag', 'labelTable'), 'Data', tableData);
end